一个电商台用户量已达到数亿级别，此时如果想要统计出所有商品的销售数量，从而知晓有哪些热点商品。如果直接从关系型数据库里直接查询并排序，性能之差可见一般，此时就一定有一个存放海量数据的日志平台来辅助商家完成对热点数据统计。如图1:

![76801400_1623901566](https://typoraimgbed.oss-cn-hangzhou.aliyuncs.com/img/76801400_1623901566.jpeg)

​                              																						图1

从图1中我们可以看到，当服务端接收到用户获取每个商品的销售量时，意味着只有一个线程从海量的日志文件里读取每一条商品销售数据进行统计，那么此时这个系统的吞吐量也是十分堪忧的,并且1秒内返回给用户数据的精确性十分有限，那么如果我们启用多线程来处理情况大致如图2：

![96475600_1623901566](https://typoraimgbed.oss-cn-hangzhou.aliyuncs.com/img/96475600_1623901566.jpeg)

​																														图2

很明显，此时虽然有多个线程可以用于统计热点数据，但是客户端只能将请求只能交给一个线程去处理请求，无法并行执行，此时就需要一个管控线程，来负责接收用户请求，并进行任务分配，从而达到多个线程并行处理热点数据统计的效果，如图3：![15227800_1623901567](https://typoraimgbed.oss-cn-hangzhou.aliyuncs.com/img/15227800_1623901567.jpeg)

​																										图3

此时客户端就可以通过连接master线程由它来进行请求的分发，但是呢，由于master线程和slave线程高度耦合，吞吐量问题始终未能解决，此时就只能引入内存队列让两个线程进行解耦，彼此的执行效率互不干扰，如图4：

![32034100_1623901567](https://typoraimgbed.oss-cn-hangzhou.aliyuncs.com/img/32034100_1623901567.jpeg)

 																																如图4

案例源码走读现在大家都对这个案例背景有些了解了，再来看看项目案例的源码加深理解，如图5：

![53001600_1623901567](https://typoraimgbed.oss-cn-hangzhou.aliyuncs.com/img/53001600_1623901567.png)

 																											图5

重点关注框出来的方法，进去看一下它的逻辑 ，如图6：

![70201100_1623901567](https://typoraimgbed.oss-cn-hangzhou.aliyuncs.com/img/70201100_1623901567.png)

 																												图6

从图中我们明显能看出Worker是一个实现了两阶段终止的线程，核心处理逻辑是由doRun方法实现的。不过我们还是先关注任务的分发逻辑。也就是dispatchTask方法的逻辑，如图7：

![94102300_1623901567](https://typoraimgbed.oss-cn-hangzhou.aliyuncs.com/img/94102300_1623901567.png)

​																														图7

大家可以跟着代码注释理解，值得一提的是makeReaderFrom方法，用到了流合并技术，也就是一个输入流包含多个文件内容，好了，这些都介绍完毕之后，我们来看看 Worker的doRun方法，如图8：

![22732700_1623901568](https://typoraimgbed.oss-cn-hangzhou.aliyuncs.com/img/22732700_1623901568.png)

​																												图8

说白了，就是对输入流中读取出来的json串中的商品id进行统计。